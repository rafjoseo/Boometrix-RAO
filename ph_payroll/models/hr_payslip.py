# from collections import defaultdict
from odoo import api, fields, models, tools, _
from odoo.addons.hr_payroll.models.browsable_object import BrowsableObject, InputLine, WorkedDays, Payslips, ResultRules
from odoo.addons.ph_payroll.models.browsable_object import BrowsableObject, PhPayslips
from odoo.tools import float_round, date_utils, convert_file, html2plaintext


class PhPayslip(models.Model):
    _inherit = 'hr.payslip'
    
    month = fields.Char()
    year = fields.Char()
    run_type = fields.Selection([('first', '1st half'),('second', '2nd half')])
    
    def _get_base_local_dict(self):
        employee = self.employee_id
        
        res = super()._get_base_local_dict()
        res.update({
            'compute_withholding_taxes': compute_withholding_taxes,
            'compute_sss_ee': compute_sss_ee,
            'compute_philhealth': compute_philhealth,
            'taxable': BrowsableObject(employee.id, {}, self.env),
            'ph_sss': BrowsableObject(employee.id, {}, self.env),
            'ph_philhealth': BrowsableObject(employee.id, {}, self.env),
            'ph_payslip': PhPayslips(employee.id, self, self.env),
        })
        return res

    def _get_payslip_lines(self):
        self.ensure_one()

        localdict = self.env.context.get('force_payslip_localdict', None)
        if localdict is None:
            localdict = self._get_localdict()

        rules_dict = localdict['rules'].dict
        result_rules_dict = localdict['result_rules'].dict

        blacklisted_rule_ids = self.env.context.get('prevent_payslip_computation_line_ids', [])

        result = {}
        
        taxable_amount = 0
        sss_amount_base = 0
        phil_amount_base = 0
        for rule in sorted(self.struct_id.rule_ids, key=lambda x: x.sequence):
            if rule.id in blacklisted_rule_ids:
                continue
            localdict.update({
                'result': None,
                'result_qty': 1.0,
                'result_rate': 100,
                'result_name': False
            })
            if rule._satisfy_condition(localdict):
                amount, qty, rate = rule._compute_rule(localdict)
                #check if there is already a rule computed with that code
                previous_amount = rule.code in localdict and localdict[rule.code] or 0.0
                #set/overwrite the amount computed for this rule in the localdict
                tot_rule = amount * qty * rate / 100.0
                localdict[rule.code] = tot_rule
                result_rules_dict[rule.code] = {'total': tot_rule, 'amount': amount, 'quantity': qty}
                rules_dict[rule.code] = rule
                # sum the amount for its salary category
                localdict = rule.category_id._sum_salary_rule_category(localdict, tot_rule - previous_amount)
                
                # ph: taxable income
                if rule.taxable:
                    taxable_amount += tot_rule
#                     rate = rule.amount_percentage
                    localdict['taxable'].dict['value'] = taxable_amount if taxable_amount else 0
                # ph: statutory contributions
                if rule.sss_contribution:
                    sss_amount_base += tot_rule
                    localdict['ph_sss'].dict['value'] = sss_amount_base if sss_amount_base else 0
                if rule.philhealth_contribution:
                    phil_amount_base += tot_rule
                    localdict['ph_philhealth'].dict['value'] = phil_amount_base if phil_amount_base else 0
                
                # Retrieve the line name in the employee's lang
                employee_lang = self.employee_id.sudo().address_home_id.lang
                # This actually has an impact, don't remove this line
                context = {'lang': employee_lang}
                if localdict['result_name']:
                    rule_name = localdict['result_name']
                elif rule.code in ['BASIC', 'GROSS', 'NET', 'DEDUCTION', 'REIMBURSEMENT']:  # Generated by default_get (no xmlid)
                    if rule.code == 'BASIC':  # Note: Crappy way to code this, but _(foo) is forbidden. Make a method in master to be overridden, using the structure code
                        if rule.name == "Double Holiday Pay":
                            rule_name = _("Double Holiday Pay")
                        if rule.struct_id.name == "CP200: Employees 13th Month":
                            rule_name = _("Prorated end-of-year bonus")
                        else:
                            rule_name = _('Basic Salary')
                    elif rule.code == "GROSS":
                        rule_name = _('Gross')
                    elif rule.code == "DEDUCTION":
                        rule_name = _('Deduction')
                    elif rule.code == "REIMBURSEMENT":
                        rule_name = _('Reimbursement')
                    elif rule.code == 'NET':
                        rule_name = _('Net Salary')
                else:
                    rule_name = rule.with_context(lang=employee_lang).name
                # create/overwrite the rule in the temporary results
                result[rule.code] = {
                    'sequence': rule.sequence,
                    'code': rule.code,
                    'name': rule_name,
                    'note': html2plaintext(rule.note),
                    'salary_rule_id': rule.id,
                    'contract_id': localdict['contract'].id,
                    'employee_id': localdict['employee'].id,
                    'amount': amount,
                    'quantity': qty,
                    'rate': rate,
                    'slip_id': self.id,
                }
        return result.values()
    
    def _search_tax_table_floor(self, tax_table, taxable_amount):
        conditions = [
            ('category', "=", tax_table),
            ('floor', '<=', taxable_amount),
            ('ceiling', '>=', taxable_amount),
        ]
        return self.env['ph.tax.table'].search(conditions, limit=1).floor
    
    def _search_tax_table_absolute(self, tax_table, taxable_amount):
        conditions = [
            ('category', "=", tax_table),
            ('floor', '<=', taxable_amount),
            ('ceiling', '>=', taxable_amount),
        ]
        return self.env['ph.tax.table'].search(conditions, limit=1).absolute
    
    def _search_tax_table_rate(self, tax_table, taxable_amount):
        conditions = [
            ('category', "=", tax_table),
            ('floor', '<=', taxable_amount),
            ('ceiling', '>=', taxable_amount),
        ]
        return self.env['ph.tax.table'].search(conditions, limit=1).rate
    
    def _search_sss_table(self, sss_amount_base, sss_item):
        result = 0.0
        conditions = [
            ('salary_from', '<=', sss_amount_base),
            ('salary_to', '>=', sss_amount_base),
        ]
        if sss_item == 'SSSEE':
            result = self.env['ph.sss.table'].search(conditions, limit=1).sss_ee
        elif  sss_item == 'SSSER':
            result = self.env['ph.sss.table'].search(conditions, limit=1).sss_er
        elif  sss_item == 'ECER':
            result = self.env['ph.sss.table'].search(conditions, limit=1).ec_er
        elif  sss_item == 'WISPEE':
            result = self.env['ph.sss.table'].search(conditions, limit=1).wisp_ee
        elif  sss_item == 'WISPER':
            result = self.env['ph.sss.table'].search(conditions, limit=1).wisp_er
        return result
    
    def _search_philhealth_table(self, philhealth_year, philhealth_amount_base, philhealth_item):
        result = 0.0
        conditions = [
            ('year', '=', philhealth_year),
            ('salary_from', '<=', philhealth_amount_base),
            ('salary_to', '>=', philhealth_amount_base),
        ]
        if philhealth_item == 'category':
            result = self.env['ph.philhealth.table'].search(conditions, limit=1).category
        elif  philhealth_item == 'premium':
            result = self.env['ph.philhealth.table'].search(conditions, limit=1).premium
        return result
    
    
def compute_sss_ee(payslip, ph_payslip, ph_sss, sss_item):  
    sss_amount = 0
    previous_sss_amount_base = ph_payslip.sum('SSSGROSS', payslip.month, payslip.year)
    previous_sss_amount = ph_payslip.sum(sss_item, payslip.month, payslip.year)
    sss_amount_base = ph_sss.value + previous_sss_amount_base
    if sss_amount_base:
        sss_amount = payslip.env['hr.payslip'].sudo()._search_sss_table(sss_amount_base, sss_item)
    sss_amount += previous_sss_amount if previous_sss_amount else 0
    return -sss_amount


def compute_philhealth(payslip, ph_payslip, ph_philhealth):  
    philhealth_amount = 0
    previous_philhealth_amount_base = ph_payslip.sum('PHILGROSS', payslip.month, payslip.year)
    previous_philhealth_amount = ph_payslip.sum('PHILEE', payslip.month, payslip.year)
    philhealth_amount_base = ph_philhealth.value + previous_philhealth_amount_base
    if philhealth_amount_base:
        r_category = payslip.env['hr.payslip'].sudo()._search_philhealth_table(payslip.year, philhealth_amount_base, 'category') 
        r_premium = payslip.env['hr.payslip'].sudo()._search_philhealth_table(payslip.year, philhealth_amount_base, 'premium')
        if r_category == 'amount':
            philhealth_amount = r_premium
        elif r_category == 'rate':
            philhealth_amount = philhealth_amount_base * r_premium
            
    philhealth_amount += previous_philhealth_amount if previous_philhealth_amount else 0
    return -philhealth_amount


def compute_withholding_taxes(payslip, ph_payslip, taxable, tax_table):  
    # month-to-date record
    previous_taxable_amount = ph_payslip.sum('TAXINC', payslip.month, payslip.year)
    previous_withholding_tax = ph_payslip.sum('WTAX', payslip.month, payslip.year)
    # get table variants
    taxable_amount = taxable.value + previous_taxable_amount
    withholding_tax = 0
    r_floor = payslip.env['hr.payslip'].sudo()._search_tax_table_floor(tax_table, taxable_amount)
    r_rate = payslip.env['hr.payslip'].sudo()._search_tax_table_rate(tax_table, taxable_amount)
    r_absolute = payslip.env['hr.payslip'].sudo()._search_tax_table_absolute(tax_table, taxable_amount)
    # compute tax
    if taxable_amount:
        withholding_tax = (taxable_amount - r_floor) * r_rate + r_absolute
    
    withholding_tax += previous_withholding_tax if previous_withholding_tax else 0
    return -withholding_tax



    
    
    
    

